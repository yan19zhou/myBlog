

## 基础概念

### 	

### 1、修饰符

- i —— 对大小写不敏感，例如/test/i不仅可以匹配test，还可以匹配Test、TEST、tEsT等。
- g —— 查找所有匹配项，在查找到第一个匹配时不会停止，会继续查找下一个匹配项。稍后会详细介绍。
- m —— 允许多行匹配，对获取textarea元素的值很有用。
- y —— 开启粘连匹配。正则表达式执行粘连匹配时试图从最后一个匹配的位置开始。
- u —— 允许使用Unicode点转义符（\u{…}）。

​	

### 	2、术语和操作符

- ####  精确匹配：

  - 如：正则/test/中的4个字符，必须完全出现在所匹配的字符串中

- #### 匹配字符集

  - [abc]表示匹配a、b、c中的任意一个字符
  - [^abl]表示匹配a、b、c之外的任意一个字符	
  - [a-m] 表示字母a到m之间的所有字符集合	

- #### 转义

  > 特殊字符如$、句号(.)匹配的是它们本身以外的内容，或者表示操作符。要表示他们本身的话，需要在前面添加反斜杠\转义符。

- #### 起止符号

  > /^test$/   ^匹配字符串的开始，$匹配字符串的结束

- #### 重复出现

  - 指定可选字符（可以出现0次或1次），在字符后添加 ? ，例如，/t?est/可以同时匹配test与est。

  - 指定字符必须出现1次或多次，使用 + ，如/t+est/可匹配test、ttest、tttest等。

  - 指定字符出现0次或1次或多次，使用 * ，如/t*est/匹配test、ttest、tttest以及est。

  - 指定重复次数，使用括号指定重复次数，例如 /a{4}/，匹配4个连续的字符a。

  - 指定重复次数的范围，使用逗号分隔，例如/a{4,10}/匹配4~10个连续的字符a。

  - 指定开放区间，省略第2个值，保留逗号。例如/a{4,}/匹配4个或更多个连续的字符a。

    > 这些运算符都可以是贪婪的或非贪婪的。默认是贪婪模式，可以匹配所有可能的字符。在运算符后添加?，例如a+?，使得运算符为非贪婪模式，只进行最小限度的匹配。
    > 例如，对于字符串aaa，正则表达式/a+/会匹配全部3个字符，而非贪婪模式/a+?/则匹配一个字符a，因为一个字符a足以满足a+术语。

- #### 预定义字符集

  | 预定义元字符  | 匹配的字符集                                              |
  | ------------- | :-------------------------------------------------------- |
  | \t            | 水平制表符                                                |
  | \b            | 空格                                                      |
  | \v            | 垂直制表符                                                |
  | \f            | 换页符                                                    |
  | \r            | 回车符                                                    |
  | \n            | 换行符                                                    |
  | \cA:\cZ       | 控制字符                                                  |
  | \u0000:\uFFFF | 十六进制Unicode 码                                        |
  | \x00:\xFF     | 十六进制ASCII 码                                          |
  | .             | 匹配除换行字符（\n、\r、\u2028和\u2029）之外的任意字符    |
  | \d            | 匹配任意十进制数字，等价于[0-9]                           |
  | \D            | 匹配除了十进制数字外的任意字符，等价于[^0-9]              |
  | \w            | 匹配任何字母、数字和下划线，等价于[A-Za-z0-9_]            |
  | \W            | 匹配除了字母、数字和下划线之外的字符，等价于[^A-Za-z0-9_] |
  | \s            | 匹配任意空白字符（包括空格、制表符、换页符等）            |
  | \S            | 匹配除空白字符外的任意字符                                |
  | \b            | 匹配单词边界                                              |
  | \B            | 匹配非单词边界(单词内部)                                  |

- #### 分组

  > 如果对一组术语使用操作符，可以使用圆括号进行分组，这与数学表达式类似。例如，/(ab)+/匹配一个或多个连续的ab。

- #### 或操作符(OR)

  > 使用竖线(|)表示或。例如，/a|b/可以匹配a或者b，/(ab)+|(cd)+/可以匹配一个或多个ab或cd。

- #### 反向引用

  >反向引用可引用正则中定义的捕获,现在只需要把捕获看作待匹配的字符串，也就是前面匹配的字符串。反向引用分组中捕获的内容，使用反斜线加上数字表示引用，该数字从1开始，第一个分组捕获的为\1，第二个为\2，以此类推。

  > 例如正则表达式/^([dtn])a\1/，匹配的是：以字母d、t或n开头，其后连接字母a，再后连接第一个分组中捕获的内容。最后一点重要！这种匹配规则与正则表达式/[dtn] a[dtn]/是不同的。A后面连接的字母不是任意的字母d、t或n，而必须与第一个分组中匹配到的字母完全相同。因此，\1匹配的具体字母是在运行时才能确定。

#### 创建正则表达式

```js
const re1 = /test/i; 　//　⇽---　通过字面量创建正则
const re2 = new RegExp("test", "i");　//　⇽---　通过构造函数创建正则
const regex =　new RegExp("(^|\\s)" + className + "(\\s|$)"); //　⇽---　使用传入的class名编译正则
regex.test(elems[i].className)) //　⇽---　检测是否与正则匹配
　　　
```



#### 正则基础规则

	字面值形式的，记得表达式前后加上 /  符号。
	\  : 转义字符，普通字符前面加上 \  可以代表特殊意义的字符。特殊意义的字符，也可以将其转换为普通字符。 当使用
	new RegExp("pattern")方法的时候不要忘记将\它自己进行转义，因为\在字符串里面也是一个转义字符。
	^  : 匹配输入的开始。匹配行首的字符。
	*  : 匹配前一个字符0次或者是多次。
	+  : 匹配前面一个字符1次或者多次，和{1,}有相同的效果。
	?  : 匹配前面一个字符0次或者1次，和{0,1}有相同的效果。
	.  : （小数点）匹配任何除了新一行开头字符的任何单个字符。
	(x)  : 匹配‘x’并且记住匹配项。这个被叫做捕获括号。可以通过数组得到匹配的对象。
	(?:x)  : 匹配'x'但是不记住匹配项。这种被叫做非捕获括号。
	x(?=y)  : 匹配'x'仅仅当'x'后面跟着'y'.这种叫做正向肯定查找。
	x(?!y)  : 匹配'x'仅仅当'x'后面不跟着'y',这个叫做正向否定查找。
	x|y  : 匹配‘x’或者‘y’。
	{n}  : n是一个正整数，匹配了前面一个字符刚好发生了n次。
	{n,m}  : n 和 m 都是正整数。匹配前面的字符至少n次，最多m次。如果 n 或者 m 的值是0， 这个值被忽略。
	[xyz]  : 一个字符集合。匹配方括号的中任意字符。你可以使用破折号（-）来指定一个字符范围。对于点（.）和星号
	（*）这样的特殊符号在一个字符集中没有特殊的意义。他们不必进行转意，不过转意也是起作用的。
	[^xyz]  : 一个反向字符集。也就是说， 它匹配任何没有包含在方括号中的字符。你可以使用破折号（-）来指定一个字
	符范围。任何普通字符在这里都是起作用的。
	[\b]  : 匹配一个退格(U+0008)。（不要和\b混淆了。）
	\b  : 匹配一个词的边界。一个词的边界就是一个词不被另外一个词跟随的位置或者不是另一个词汇字符前边的位置。注
	意，一个匹配的词的边界并不包含在匹配的内容中。换句话说，一个匹配的词的边界的内容的长度是0。（不要和[\b]混
	淆了）
	\B  : 匹配一个非单词边界。他匹配一个前后字符都是相同类型的位置：都是单词或者都不是单词。一个字符串的开始和
	结尾都被认为是非单词。
	\cX  : 当X是处于A到Z之间的字符的时候，匹配字符串中的一个控制符。
	\d  : 匹配一个数字。等价于[0-9]。
	\D  : 匹配一个非数字字符。等价于 0-9 。
	\f  : 匹配一个换页符 (U+000C)。
	\n  : 匹配一个换行符 (U+000A)。
	\r  : 匹配一个回车符 (U+000D)。
	\s  : 匹配一个空白字符，包括空格、制表符、换页符和换行符。
	\S  : 匹配一个非空白字符。
	\t  : 匹配一个水平制表符 (U+0009)。
	\v  : 匹配一个垂直制表符 (U+000B)。
	\w  : 匹配一个单字字符（字母、数字或者下划线）。等价于[A-Za-z0-9_]。
	\W  : 匹配一个非单字字符。等价于 A-Za-z0-9_ 。
	\n  : 当 n 是一个正整数，一个返回引用到最后一个与有n插入的正值表达式(counting left parentheses)匹配的副字符
	串。
	\0  : 匹配 NULL (U+0000) 字符， 不要在这后面跟其它小数，因为 \0 是一个八进制转义序列。
	\xhh  : 匹配带有两位小数代码（hh）的字符。
	\uhhhh  : 匹配带有四位小数代码（hh）的字符。
	如果需要记住匹配项，需要使用括号，这样才能通过数组查找到。

#### 一、校验数字的表达式

1 数字：^[0-9]*$ 

2 n位的数字：^\d{n}$

3 至少n位的数字：^\d{n,}$ 

4 m-n位的数字：^\d{m,n}$ 

5 零和非零开头的数字：^(0|[1-9][0-9]*)$ 

6 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 

7 带1-2位小数的正数或负数：^(\-)?\d+(\.\d{1,2})?$ 

8 正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$ 

9 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$

10 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$

11 非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\+?[1-9][0-9]*$

12 非零的负整数：^\-[1-9][]0-9"*$ 或 ^-[1-9]\d*$

13 非负整数：^\d+$ 或 ^[1-9]\d*|0$

14 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$

15 非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$

16 非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$

17 正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$

18 负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$

19 浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$

#### 二、校验字符的表达式

1 汉字：^[\u4e00-\u9fa5]{0,}$ 

2 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 

3 长度为3-20的所有字符：^.{3,20}$ 

4 由26个英文字母组成的字符串：^[A-Za-z]+$ 

5 由26个大写英文字母组成的字符串：^[A-Z]+$ 

6 由26个小写英文字母组成的字符串：^[a-z]+$ 

7 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 

8 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$ 

9 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$

10 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$

11 可以输入含有^%&',;=?$\"等字符：[^%&',;=?$\x22]+

12 禁止输入含有~的字符：[^~\x22]+

#### 三、特殊需求表达式

1 Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$ 

2 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? 

3 InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&=]*)?$ 

4 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$ 

5 电话号码("XXX-XXXXXXX"、"XXXX-XXXXXXXX"、"XXX-XXXXXXX"、"XXX-XXXXXXXX"、"XXXXXXX"和"XXXXXXXX)：^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$  

6 国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7} 

7 身份证号(15位、18位数字)：^\d{15}|\d{18}$ 

8 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$ 

9 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$

10 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$

11 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$

12 数字不能连续6位： (?=\d+)(?!([\d])\1{5})[\d]{6}

12 日期格式：^\d{4}-\d{1,2}-\d{1,2}

13 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$

14 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$

15 钱的输入格式：

16 1.有四种钱的表示形式我们可以接受:"10000.00" 和 "10,000.00", 和没有 "分" 的 "10000" 和 "10,000"：^[1-9][0-9]*$

17 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符"0"不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$

18 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$

19 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$

20 5.必须说明的是,小数点后面至少应该有1位数,所以"10."是不通过的,但是 "10" 和 "10.2" 是通过的：^[0-9]+(.[0-9]{2})?$

21 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$

22 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$

23 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$

24 备注：这就是最终结果了,别忘了"+"可以用"*"替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里

25 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$

26 中文字符的正则表达式：[\u4e00-\u9fa5]

27 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))

28 空白行的正则表达式：\n\s*\r (可以用来删除空白行)

29 HTML标记的正则表达式：<(\S*?)[^>]*>.*?</\1>|<.*? /> (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)

30 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)

31 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始)

32 中国邮政编码：[1-9]\d{5}(?!\d) (中国邮政编码为6位数字) 

33 IP地址：\d+\.\d+\.\d+\.\d+ (提取IP地址时有用) 34 IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)) 
	

